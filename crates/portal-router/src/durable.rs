use std::fmt::Display;
use std::str::FromStr;

use matic_portal_types::{ControlMessage, Nexus, NexusParseError};
use worker::{
    console_log, durable_object, Env, Error, Request, Response, State, WebSocket,
    WebSocketIncomingMessage, WebSocketPair,
};

use crate::token::worker_global::crypto;

/// An enum describing the routes that the DurableRouter can handle
#[derive(Debug)]
enum ServiceRoute {
    /// A host is connecting.
    HostControl,
    /// A host wants to accept an incoming client connection.
    HostAccept(Nexus),
    /// A client wants to connect to the given service name.
    // FIXME: use ServiceName type instead.
    Client(String),
}

#[durable_object]
pub struct DurableRouter {
    state: State,
    _env: Env, // access `Env` across requests, use inside `fetch`
}

/// Generate a random nexus value.
///
/// This value is generated by the server, and is sent to the host
/// to facilitate a callback connection. It is not sent to the client.
fn random_nexus() -> Nexus {
    let mut random_bytes = [0u8; 8];
    let crypto = crypto();
    crypto
        .get_random_values_with_u8_array(&mut random_bytes)
        .unwrap();
    let nexus_int = u64::from_ne_bytes(random_bytes);
    Nexus::new(nexus_int)
}

struct SocketInfo {
    portal_id: String,
    socket_tag: SocketTag,
}

impl SocketInfo {
    fn to_tags(&self) -> [String; 2] {
        [
            format!("portal-id-{}", self.portal_id),
            self.socket_tag.to_string(),
        ]
    }

    fn try_from_tags<I, S>(tags: I) -> Result<Self, SocketTagParseError>
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
    {
        let mut portal_id = None;
        let mut socket_tag = None;

        for tag in tags {
            let tag = tag.as_ref();

            if let Some(pid) = tag.strip_prefix("portal-id-") {
                let prev = portal_id.replace(pid.to_owned());
                // We only expect one portal id tag
                if let Some(prev) = prev {
                    console_log!("multiple portal id tags found, ignoring {prev}");
                }
                continue;
            }

            match tag.parse::<SocketTag>() {
                Ok(st) => {
                    let prev = socket_tag.replace(st);
                    // We only expect one socket type tag
                    if let Some(prev) = prev {
                        console_log!("multiple socket tags found, ignoring {prev}");
                    }
                }
                Err(_) => console_log!("unrecognized tag {tag}"),
            }
        }

        let portal_id = portal_id.ok_or(SocketTagParseError)?;
        let socket_tag = socket_tag.ok_or(SocketTagParseError)?;

        Ok(Self {
            portal_id,
            socket_tag,
        })
    }
}

#[derive(Debug, Clone)]
enum SocketTag {
    HostControl,
    HostData(Nexus),
    ClientData(Nexus),
}

impl SocketTag {
    /// Calculate the client tag that matches a host tag.
    ///
    /// If `self` is not a host tag, returns `None`.
    fn to_client(&self) -> Option<Self> {
        if let SocketTag::HostData(nexus) = self {
            Some(SocketTag::ClientData(nexus.to_owned()))
        } else {
            None
        }
    }

    /// Calculate the tag that matches the peer socket.
    ///
    /// If `self` is a client tag, returns the corresponding host tag.
    /// If `self` is a host tag, returns the corresponding client tag.
    /// If `self` is not a host or client tag, returns `None`.
    fn to_peer(&self) -> Option<Self> {
        match self {
            SocketTag::HostData(nexus) => Some(SocketTag::ClientData(nexus.to_owned())),
            SocketTag::ClientData(nexus) => Some(SocketTag::HostData(nexus.to_owned())),
            _ => None,
        }
    }
}

impl Display for SocketTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            // These strings are intended to be used as "tags" so we can
            // identify websockets in the CF "hibernation" model.
            SocketTag::HostControl => f.write_str("hc"),
            SocketTag::HostData(nexus) => write!(f, "h-{}", nexus),
            SocketTag::ClientData(nexus) => write!(f, "c-{}", nexus),
        }
    }
}

#[derive(Debug, Clone, Copy, thiserror::Error)]
#[error("error parsing socket tag")]
pub struct SocketTagParseError;

impl From<NexusParseError> for SocketTagParseError {
    fn from(_: NexusParseError) -> Self {
        Self
    }
}

impl FromStr for SocketTag {
    type Err = SocketTagParseError;

    fn from_str(tag: &str) -> Result<Self, Self::Err> {
        if tag == "hc" {
            return Ok(SocketTag::HostControl);
        }
        if let Some(nexus_str) = tag.strip_prefix("h-") {
            let nexus = nexus_str.parse()?;
            return Ok(SocketTag::HostData(nexus));
        }
        if let Some(nexus_str) = tag.strip_prefix("c-") {
            let nexus = nexus_str.parse()?;
            return Ok(SocketTag::ClientData(nexus));
        }
        Err(SocketTagParseError)
    }
}

#[durable_object]
impl DurableObject for DurableRouter {
    fn new(state: State, env: Env) -> Self {
        Self { state, _env: env }
    }

    async fn fetch(&mut self, req: Request) -> worker::Result<Response> {
        let Ok(Some(portal_id)) = req.headers().get("portal-id") else {
            return Response::error("No portal id found", 400);
        };

        let path = req.path();
        let route = Self::parse_path(&path);
        match route {
            None => {
                console_log!("DurableRouter fetch 404");
                Response::error("Not Found", 404)
            }
            Some(ServiceRoute::Client(service_name)) => {
                self.handle_client(service_name, portal_id).await
            }
            Some(ServiceRoute::HostControl) => self.handle_host_control(portal_id).await,
            Some(ServiceRoute::HostAccept(nexus)) => {
                self.handle_host_accept(nexus, portal_id).await
            }
        }
    }

    async fn websocket_message(
        &mut self,
        ws: WebSocket,
        message: WebSocketIncomingMessage,
    ) -> worker::Result<()> {
        let tags = self.state.get_tags(&ws);

        // Figure out if the sender is a host or client. Skip over any broken tags.
        let socket_info = SocketInfo::try_from_tags(tags).map_err(|_| {
            // FIXME: is there a better way to compose this error?
            worker::Error::RustError("missing peer and/or portal id".into())
        })?;
        console_log!("message sent for portal id: {}", socket_info.portal_id);

        let result = match socket_info.socket_tag {
            SocketTag::HostControl => {
                // Well-behaved hosts should not do this.
                console_log!("warning: host sent a message on host control socket");
                Err(ProtocolError::BadMessage)
            }
            SocketTag::HostData(nexus) => self.message_from_host(nexus, message),
            SocketTag::ClientData(nexus) => self.message_from_client(nexus, message),
        };
        if result.is_err() {
            console_log!("closing sender socket due to error");
            let _ = ws.close(None, None::<&str>);
        }

        Ok(())
    }

    async fn websocket_close(
        &mut self,
        ws: WebSocket,
        code: usize,
        reason: String,
        _was_clean: bool,
    ) -> worker::Result<()> {
        console_log!("websocket close, code {code} reason {reason}");
        self.handle_websocket_close(ws)
    }

    async fn websocket_error(&mut self, ws: WebSocket, error: worker::Error) -> worker::Result<()> {
        console_log!("websocket error {error}");
        self.handle_websocket_close(ws)
    }
}

impl DurableRouter {
    fn handle_websocket_close(&mut self, ws: WebSocket) -> worker::Result<()> {
        let tags = self.state.get_tags(&ws);

        let socket_info = SocketInfo::try_from_tags(tags)
            .map_err(|_| worker::Error::RustError("missing peer and/or portal id".into()))?;

        console_log!(
            "socket {} closed on portal id {}",
            socket_info.socket_tag,
            socket_info.portal_id
        );

        match socket_info.socket_tag {
            SocketTag::HostControl => {
                console_log!("host control socket closed");
            }
            tag => {
                if let Some(peer_tag) = tag.to_peer() {
                    self.close_peer(peer_tag);
                }
            }
        }
        // Respond to any closing request we receive. This ensures that the websockets don't linger in a closing state.
        if let Err(e) = ws.close(Some(1000), Some("Durable Object is closing WebSocket")) {
            console_log!("error while closing websocket: {e}");
        }
        Ok(())
    }

    fn close_peer(&mut self, tag: SocketTag) {
        let sockets = self.state.get_websockets_with_tag(&tag.to_string());
        for socket in sockets {
            // We don't supply a code or reason. We don't care if the close fails.

            // FIXME: remove after debug
            console_log!("close peer socket with tag {tag}");

            let _ = socket.close(None, None::<&str>);
        }
    }

    fn parse_path(path: &str) -> Option<ServiceRoute> {
        // FIXME: deduplicate the path parsing between the worker::Router and this?

        if path == "/connect/host_control" {
            return Some(ServiceRoute::HostControl);
        }
        if let Some(nexus_str) = path.strip_prefix("/connect/host_accept/") {
            match nexus_str.parse() {
                Ok(nexus) => return Some(ServiceRoute::HostAccept(nexus)),
                Err(_) => return None,
            }
        }
        if let Some(service_name) = path.strip_prefix("/connect/client/") {
            return Some(ServiceRoute::Client(service_name.to_owned()));
        }
        None
    }

    fn send_message(ws: &WebSocket, message: ControlMessage) -> Result<(), Error> {
        let json_msg = serde_json::to_string(&message).unwrap();
        ws.send_with_str(json_msg)
    }

    /// Search for a websocket with a given tag.
    fn find_websockets(&self, tag: &SocketTag) -> Vec<WebSocket> {
        let sockets = self.state.get_websockets_with_tag(&tag.to_string());
        if sockets.len() > 1 {
            console_log!("warning! multiple client sockets found for tag {tag}");
        }
        sockets
    }

    /// Close all websockets with a given tag.
    fn close_tagged_websockets(&self, tag: &str, reason: &str) {
        let tag = tag.to_string();
        for socket in self.state.get_websockets_with_tag(&tag) {
            // Code 1001: endpoint is "going away".
            // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4
            let _ = socket.close(Some(1001), Some(reason));
            console_log!("closing socket with {tag}");
        }
    }

    /// Handle incoming host control request.
    ///
    /// We will store a new host control websocket, and return its peer.
    /// Nothing more will happen until a client connects.
    async fn handle_host_control(&mut self, portal_id: String) -> worker::Result<Response> {
        // Kill off any existing host control sockets.
        self.close_tagged_websockets("hc", "replaced by new host");

        let pair = WebSocketPair::new()?;
        let host_ws = pair.client;
        let server_ws = pair.server;

        let socket_info = SocketInfo {
            portal_id,
            socket_tag: SocketTag::HostControl,
        };
        let tags = socket_info.to_tags();
        self.state
            .accept_websocket_with_tags(&server_ws, tags.each_ref().map(String::as_str).as_slice());

        if let Err(e) = Self::send_message(
            &server_ws,
            ControlMessage::Status("hello host from portal-router".into()),
        ) {
            console_log!("error sending status message to host: {e}");
        }

        Response::from_websocket(host_ws)
    }

    /// Handle incoming host accept request.
    ///
    /// We will store a new host websocket, and return its peer.
    /// We will also send a connected message to the corresponding client.
    async fn handle_host_accept(
        &mut self,
        nexus: Nexus,
        portal_id: String,
    ) -> worker::Result<Response> {
        let host_tag = SocketTag::HostData(nexus);
        let client_tag = host_tag.to_client().unwrap();

        // We should only allow this connection if this client is connected.
        let client_sockets = self.find_websockets(&client_tag);
        // We only expect one client socket or none.
        let Some(client_socket) = client_sockets.into_iter().next() else {
            console_log!("client socket {client_tag} not found");
            return Response::error("client socket not available", 503);
        };

        // Store this websocket using the host tag so we can find it later.
        let pair = WebSocketPair::new()?;
        let client_ws = pair.client;
        let server_ws = pair.server;

        let socket_info = SocketInfo {
            portal_id,
            socket_tag: host_tag,
        };
        let tags = socket_info.to_tags();
        self.state.accept_websocket_with_tags(
            &server_ws,
            &tags.each_ref().map(String::as_str).as_slice(),
        );

        // Inform the client that the connection is established, so it
        // knows that data transfer can begin.
        if let Err(e) = Self::send_message(&client_socket, ControlMessage::Connected) {
            console_log!("error while sending Connected message to client: {e}");
        }

        Response::from_websocket(client_ws)
    }

    // Handle incoming client request.
    ///
    /// If the `DurableRouter` is healthy, we will generate a new websocket
    /// for this client, and move messages back and forth between the host
    /// and this client.
    async fn handle_client(
        &mut self,
        service_name: String,
        portal_id: String,
    ) -> worker::Result<Response> {
        // We should only allow this connection if the server has already connected.
        let control_tag = SocketTag::HostControl;
        let host_sockets = self.find_websockets(&control_tag);
        if host_sockets.is_empty() {
            console_log!("host socket {control_tag} not found");
            return Response::error("tunnel host not available", 503);
        };

        let pair = WebSocketPair::new()?;
        let client_ws = pair.client;
        let server_ws = pair.server;

        // Generate a random nexus value so we can match host and client sockets.
        let nexus = random_nexus();
        let socket_info = SocketInfo {
            portal_id,
            socket_tag: SocketTag::ClientData(nexus),
        };
        let tags = socket_info.to_tags();
        self.state.accept_websocket_with_tags(
            &server_ws,
            &tags.each_ref().map(String::as_str).as_slice(),
        );

        // Loop over all host sockets until a send is successful.
        // Since the websocket's ready_state is not accessible to us, this ensures we send over an open socket if available.
        let mut delivered = false;
        for host_socket in host_sockets {
            // Inform the host that a new client has arrived.
            // The host can decide whether to accept the connection.
            match Self::send_message(
                &host_socket,
                ControlMessage::Incoming {
                    // FIXME: we threw away the client name in lib.rs when
                    // doing auth. Need to find a way to plumb that value through.
                    client_name: String::new(),
                    service_name: service_name.clone(),
                    nexus,
                },
            ) {
                Err(e) => {
                    console_log!("error sending incoming message to host: {e}");
                }
                Ok(_) => {
                    if delivered {
                        console_log!("warning! found multiple open host control sockets");
                    }
                    delivered = true;
                }
            }
        }

        if !delivered {
            console_log!("failed to send incoming message to any host socket");
            return Response::error("tunnel host not available: no open connections", 503);
        }

        if let Err(e) = Self::send_message(
            &server_ws,
            ControlMessage::Status("hello client from portal-router".into()),
        ) {
            console_log!("error sending status message to client: {e}");
        }

        Response::from_websocket(client_ws)
    }

    /// Handle a message from the host.
    ///
    /// If we fail to send the message to the peer client, we will return an error.
    fn message_from_host(
        &self,
        nexus: Nexus,
        message: WebSocketIncomingMessage,
    ) -> Result<(), ProtocolError> {
        match message {
            WebSocketIncomingMessage::String(_) => {
                // Text messages should only come from the server, not a peer.
                // Otherwise ControlMessage spoofing might be possible.
                console_log!("improper string message from host");
                Err(ProtocolError::BadMessage)
            }
            WebSocketIncomingMessage::Binary(msg) => {
                let client_tag = SocketTag::ClientData(nexus);
                // We only expect one client socket since a nexus is randomly generated for each connection.
                // If there are multiple, we log a warning in find_websockets.
                let Some(client_socket) = self.find_websockets(&client_tag).into_iter().next()
                else {
                    console_log!("client socket {client_tag} not found");
                    return Err(ProtocolError::PeerBroken);
                };
                client_socket.send_with_bytes(msg).map_err(|e| {
                    console_log!("error sending to client: {e}");
                    ProtocolError::PeerBroken
                })
            }
        }
    }

    /// Handle a message from the client.
    ///
    /// If we fail to send the message to the peer host, we will return an error.
    fn message_from_client(
        &self,
        nexus: Nexus,
        message: WebSocketIncomingMessage,
    ) -> Result<(), ProtocolError> {
        match message {
            WebSocketIncomingMessage::String(_) => {
                // Text messages should only come from the server, not a peer.
                // Otherwise ControlMessage spoofing might be possible.
                console_log!("improper string message from client");
                Err(ProtocolError::BadMessage)
            }
            WebSocketIncomingMessage::Binary(msg) => {
                let host_tag = SocketTag::HostData(nexus);
                // We only expect one host socket since a nexus is randomly generated for each connection.
                // If there are multiple, we log a warning in find_websockets.
                let Some(host_socket) = self.find_websockets(&host_tag).into_iter().next() else {
                    console_log!("host socket {host_tag} not found");
                    return Err(ProtocolError::PeerBroken);
                };
                host_socket.send_with_bytes(msg).map_err(|e| {
                    console_log!("error sending to host: {e}");
                    ProtocolError::PeerBroken
                })
            }
        }
    }
}

#[derive(Debug, Clone, Copy, thiserror::Error)]
pub enum ProtocolError {
    #[error("message not allowed")]
    BadMessage,
    #[error("failed to send to peer")]
    PeerBroken,
}
