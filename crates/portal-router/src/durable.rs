use std::fmt::Display;
use std::str::FromStr;

use matic_portal_types::{ControlMessage, Nexus, NexusParseError};
use worker::{
    console_log, durable_object, Env, Request, Response, State, WebSocket,
    WebSocketIncomingMessage, WebSocketPair,
};

use crate::token::worker_global::crypto;

/// An enum describing the routes that the DurableRouter can handle
#[derive(Debug)]
enum ServiceRoute {
    /// A host is connecting.
    HostControl,
    /// A host wants to accept an incoming client connection.
    HostAccept(Nexus),
    /// A client wants to connect to the given service name.
    // FIXME: use ServiceName type instead.
    Client(String),
}

#[durable_object]
pub struct DurableRouter {
    state: State,
    _env: Env, // access `Env` across requests, use inside `fetch`
}

/// Generate a random nexus value.
///
/// This value is generated by the server, and is sent to the host
/// to facilitate a callback connection. It is not sent to the client.
fn random_nexus() -> Nexus {
    let mut random_bytes = [0u8; 8];
    let crypto = crypto();
    crypto
        .get_random_values_with_u8_array(&mut random_bytes)
        .unwrap();
    let nexus_int = u64::from_ne_bytes(random_bytes);
    Nexus::new(nexus_int)
}

#[derive(Debug, Clone)]
enum SocketTag {
    HostControl,
    HostData(Nexus),
    ClientData(Nexus),
}

impl SocketTag {
    /// Calculate the client tag that matches a host tag.
    ///
    /// If `self` is not a host tag, returns `None`.
    fn to_client(&self) -> Option<Self> {
        if let SocketTag::HostData(nexus) = self {
            Some(SocketTag::ClientData(nexus.to_owned()))
        } else {
            None
        }
    }

    /// Calculate the tag that matches the peer socket.
    ///
    /// If `self` is a client tag, returns the corresponding host tag.
    /// If `self` is a host tag, returns the corresponding client tag.
    /// If `self` is not a host or client tag, returns `None`.
    fn to_peer(&self) -> Option<Self> {
        match self {
            SocketTag::HostData(nexus) => Some(SocketTag::ClientData(nexus.to_owned())),
            SocketTag::ClientData(nexus) => Some(SocketTag::HostData(nexus.to_owned())),
            _ => None,
        }
    }
}

impl Display for SocketTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            // These strings are intended to be used as "tags" so we can
            // identify websockets in the CF "hibernation" model.
            SocketTag::HostControl => f.write_str("hc"),
            SocketTag::HostData(nexus) => write!(f, "h-{}", nexus),
            SocketTag::ClientData(nexus) => write!(f, "c-{}", nexus),
        }
    }
}

#[derive(Debug, Clone, Copy, thiserror::Error)]
#[error("error parsing socket tag")]
pub struct SocketTagParseError;

impl From<NexusParseError> for SocketTagParseError {
    fn from(_: NexusParseError) -> Self {
        Self
    }
}

impl FromStr for SocketTag {
    type Err = SocketTagParseError;

    fn from_str(tag: &str) -> Result<Self, Self::Err> {
        if tag == "hc" {
            return Ok(SocketTag::HostControl);
        }
        if let Some(nexus_str) = tag.strip_prefix("h-") {
            let nexus = nexus_str.parse()?;
            return Ok(SocketTag::HostData(nexus));
        }
        if let Some(nexus_str) = tag.strip_prefix("c-") {
            let nexus = nexus_str.parse()?;
            return Ok(SocketTag::ClientData(nexus));
        }
        Err(SocketTagParseError)
    }
}

#[durable_object]
impl DurableObject for DurableRouter {
    fn new(state: State, env: Env) -> Self {
        Self { state, _env: env }
    }

    async fn fetch(&mut self, req: Request) -> worker::Result<Response> {
        let path = req.path();
        let route = Self::parse_path(&path);
        match route {
            None => {
                console_log!("DurableRouter fetch 404");
                Response::error("Not Found", 404)
            }
            Some(ServiceRoute::Client(service_name)) => self.handle_client(service_name).await,
            Some(ServiceRoute::HostControl) => self.handle_host_control().await,
            Some(ServiceRoute::HostAccept(nexus)) => self.handle_host_accept(nexus).await,
        }
    }

    async fn websocket_message(
        &mut self,
        ws: WebSocket,
        message: WebSocketIncomingMessage,
    ) -> worker::Result<()> {
        let tags = self.state.get_tags(&ws);

        // Figure out if the sender is a host or client. Skip over any broken tags.
        let socket_tag = tags
            .iter()
            .filter_map(|tag| {
                tag.parse::<SocketTag>()
                    .inspect_err(|_| console_log!("unrecognized tag {tag}"))
                    .ok()
            })
            .next();
        let Some(socket_tag) = socket_tag else {
            // FIXME: is there a better way to compose this error?
            return Err(worker::Error::RustError("missing peer".into()));
        };

        let result = match socket_tag {
            SocketTag::HostControl => {
                // Well-behaved hosts should not do this.
                console_log!("warning: host sent a message on host control socket");
                Err(ProtocolError::BadMessage)
            }
            SocketTag::HostData(nexus) => self.message_from_host(nexus, message),
            SocketTag::ClientData(nexus) => self.message_from_client(nexus, message),
        };
        if result.is_err() {
            console_log!("closing sender socket due to error");
            let _ = ws.close(None, None::<&str>);
        }

        Ok(())
    }

    async fn websocket_close(
        &mut self,
        ws: WebSocket,
        code: usize,
        reason: String,
        _was_clean: bool,
    ) -> worker::Result<()> {
        console_log!("websocket close, code {code} reason {reason}");
        self.handle_websocket_close(ws);
        Ok(())
    }

    async fn websocket_error(&mut self, ws: WebSocket, error: worker::Error) -> worker::Result<()> {
        console_log!("websocket error {error}");
        self.handle_websocket_close(ws);
        Ok(())
    }
}

impl DurableRouter {
    fn handle_websocket_close(&mut self, ws: WebSocket) {
        let tags = self.state.get_tags(&ws);

        for tag in tags {
            match tag.parse::<SocketTag>() {
                Ok(SocketTag::HostControl) => {
                    // FIXME: we should print the portal id here.
                    console_log!("host control socket closed");
                    break;
                }
                Ok(tag) => {
                    if let Some(peer_tag) = tag.to_peer() {
                        self.close_peer(peer_tag);
                    }
                    break;
                }
                Err(_) => console_log!("unrecognized tag {tag}"),
            }
        }
        // Respond to any closing request we receive. This ensures that the websockets don't linger in a closing state.
        if let Err(e) = ws.close(Some(1000), Some("Durable Object is closing WebSocket")) {
            console_log!("error while closing websocket: {e}");
        }
    }

    fn close_peer(&mut self, tag: SocketTag) {
        let sockets = self.state.get_websockets_with_tag(&tag.to_string());
        for socket in sockets {
            // We don't supply a code or reason. We don't care if the close fails.

            // FIXME: remove after debug
            console_log!("close peer socket with tag {tag}");

            let _ = socket.close(None, None::<&str>);
        }
    }

    fn parse_path(path: &str) -> Option<ServiceRoute> {
        // FIXME: deduplicate the path parsing between the worker::Router and this?

        if path == "/connect/host_control" {
            return Some(ServiceRoute::HostControl);
        }
        if let Some(nexus_str) = path.strip_prefix("/connect/host_accept/") {
            match nexus_str.parse() {
                Ok(nexus) => return Some(ServiceRoute::HostAccept(nexus)),
                Err(_) => return None,
            }
        }
        if let Some(service_name) = path.strip_prefix("/connect/client/") {
            return Some(ServiceRoute::Client(service_name.to_owned()));
        }
        None
    }

    fn send_message(ws: &WebSocket, message: ControlMessage) {
        let json_msg = serde_json::to_string(&message).unwrap();

        if let Err(e) = ws.send_with_str(json_msg) {
            console_log!("error sending control message on socket: {e}");
        }
    }

    /// Search for a websocket with a given tag.
    fn find_websocket(&self, tag: &SocketTag) -> Option<WebSocket> {
        let sockets = self.state.get_websockets_with_tag(&tag.to_string());
        if sockets.is_empty() {
            return None;
        }
        if sockets.len() > 1 {
            console_log!("warning! multiple client sockets found for tag {tag}");
        }
        // Take the first websocket in the list.
        let socket = sockets.into_iter().next().unwrap();
        Some(socket)
    }

    /// Close all websockets with a given tag.
    fn close_tagged_websockets(&self, tag: &str, reason: &str) {
        let tag = tag.to_string();
        for socket in self.state.get_websockets_with_tag(&tag) {
            // Code 1001: endpoint is "going away".
            // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4
            let _ = socket.close(Some(1001), Some(reason));
            console_log!("closing socket with {tag}");
        }
    }

    /// Handle incoming host control request.
    ///
    /// We will store a new host control websocket, and return its peer.
    /// Nothing more will happen until a client connects.
    async fn handle_host_control(&mut self) -> worker::Result<Response> {
        // Kill off any existing host control sockets.
        self.close_tagged_websockets("hc", "replaced by new host");

        let pair = WebSocketPair::new()?;
        let host_ws = pair.client;
        let server_ws = pair.server;

        self.state.accept_websocket_with_tags(&server_ws, &["hc"]);

        Self::send_message(
            &server_ws,
            ControlMessage::Status("hello host from portal-router".into()),
        );

        Response::from_websocket(host_ws)
    }

    /// Handle incoming host accept request.
    ///
    /// We will store a new host websocket, and return its peer.
    /// We will also send a connected message to the corresponding client.
    async fn handle_host_accept(&mut self, nexus: Nexus) -> worker::Result<Response> {
        let host_tag = SocketTag::HostData(nexus);
        let client_tag = host_tag.to_client().unwrap();

        // We should only allow this connection if this client is connected.
        let Some(client_socket) = self.find_websocket(&client_tag) else {
            console_log!("client socket {client_tag} not found");
            return Response::error("client socket not available", 503);
        };

        // Store this websocket using the host tag so we can find it later.
        let pair = WebSocketPair::new()?;
        let client_ws = pair.client;
        let server_ws = pair.server;

        self.state
            .accept_websocket_with_tags(&server_ws, &[&host_tag.to_string()]);

        // Inform the client that the connection is established, so it
        // knows that data transfer can begin.
        Self::send_message(&client_socket, ControlMessage::Connected);

        Response::from_websocket(client_ws)
    }

    // Handle incoming client request.
    ///
    /// If the `DurableRouter` is healthy, we will generate a new websocket
    /// for this client, and move messages back and forth between the host
    /// and this client.
    async fn handle_client(&mut self, service_name: String) -> worker::Result<Response> {
        // We should only allow this connection if the server has already connected.
        let control_tag = SocketTag::HostControl;
        let Some(host_socket) = self.find_websocket(&control_tag) else {
            console_log!("host socket {control_tag} not found");
            return Response::error("tunnel host not available", 503);
        };

        let pair = WebSocketPair::new()?;
        let client_ws = pair.client;
        let server_ws = pair.server;

        // Generate a random nexus value so we can match host and client sockets.
        let nexus = random_nexus();
        let tag = SocketTag::ClientData(nexus).to_string();

        self.state.accept_websocket_with_tags(&server_ws, &[&tag]);

        // Inform the host that a new client has arrived.
        // The host can decide whether to accept the connection.
        Self::send_message(
            &host_socket,
            ControlMessage::Incoming {
                // FIXME: we threw away the client name in lib.rs when
                // doing auth. Need to find a way to plumb that value through.
                client_name: String::new(),
                service_name,
                nexus,
            },
        );

        Self::send_message(
            &server_ws,
            ControlMessage::Status("hello client from portal-router".into()),
        );

        Response::from_websocket(client_ws)
    }

    /// Handle a message from the host.
    ///
    /// If we fail to send the message to the peer client, we will return an error.
    fn message_from_host(
        &self,
        nexus: Nexus,
        message: WebSocketIncomingMessage,
    ) -> Result<(), ProtocolError> {
        match message {
            WebSocketIncomingMessage::String(_) => {
                // Text messages should only come from the server, not a peer.
                // Otherwise ControlMessage spoofing might be possible.
                console_log!("improper string message from host");
                Err(ProtocolError::BadMessage)
            }
            WebSocketIncomingMessage::Binary(msg) => {
                let client_tag = SocketTag::ClientData(nexus);
                let Some(client_socket) = self.find_websocket(&client_tag) else {
                    console_log!("client socket {client_tag} not found");
                    return Err(ProtocolError::PeerBroken);
                };
                client_socket.send_with_bytes(msg).map_err(|e| {
                    console_log!("error sending to client: {e}");
                    ProtocolError::PeerBroken
                })
            }
        }
    }

    /// Handle a message from the client.
    ///
    /// If we fail to send the message to the peer host, we will return an error.
    fn message_from_client(
        &self,
        nexus: Nexus,
        message: WebSocketIncomingMessage,
    ) -> Result<(), ProtocolError> {
        match message {
            WebSocketIncomingMessage::String(_) => {
                // Text messages should only come from the server, not a peer.
                // Otherwise ControlMessage spoofing might be possible.
                console_log!("improper string message from client");
                Err(ProtocolError::BadMessage)
            }
            WebSocketIncomingMessage::Binary(msg) => {
                let host_tag = SocketTag::HostData(nexus);
                let Some(host_socket) = self.find_websocket(&host_tag) else {
                    console_log!("host socket {host_tag} not found");
                    return Err(ProtocolError::PeerBroken);
                };
                host_socket.send_with_bytes(msg).map_err(|e| {
                    console_log!("error sending to host: {e}");
                    ProtocolError::PeerBroken
                })
            }
        }
    }
}

#[derive(Debug, Clone, Copy, thiserror::Error)]
pub enum ProtocolError {
    #[error("message not allowed")]
    BadMessage,
    #[error("failed to send to peer")]
    PeerBroken,
}
